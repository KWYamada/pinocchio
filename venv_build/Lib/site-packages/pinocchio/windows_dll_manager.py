import contextlib
import os
from pathlib import Path


def get_dll_paths():
    pinocchio_paths = os.getenv("PINOCCHIO_WINDOWS_DLL_PATH")
    if pinocchio_paths is None:
        package_root = Path(__file__).parent
        candidate_paths = []

        # Preferred: packaged pinocchio/bin next to the Python sources (new wheel layout)
        local_bin = package_root / "bin"
        if local_bin.exists():
            candidate_paths.append(local_bin)

        # Fallback for legacy layouts: site-packages/pinocchio/lib/pythonX/site-packages/pinocchio/bin
        legacy_bin = (package_root / Path("..\\..\\..\\bin")).resolve()
        if legacy_bin.exists():
            candidate_paths.append(legacy_bin)

        return [str(p) for p in candidate_paths] or [str(legacy_bin)]
    else:
        return [p for p in pinocchio_paths.split(os.pathsep) if p]


class PathManager(contextlib.AbstractContextManager):
    """Restore PATH state after importing Python module"""

    def add_dll_directory(self, dll_dir: str):
        os.environ["PATH"] += os.pathsep + dll_dir

    def __enter__(self):
        self.old_path = os.environ["PATH"]
        return self

    def __exit__(self, *exc_details):
        os.environ["PATH"] = self.old_path


class DllDirectoryManager(contextlib.AbstractContextManager):
    """Restore DllDirectory state after importing Python module"""

    def add_dll_directory(self, dll_dir: str):
        # add_dll_directory can fail on relative path and non
        # existing path.
        # Since we don't know all the fail criterion we just ignore
        # thrown exception
        try:
            self.dll_dirs.append(os.add_dll_directory(dll_dir))
        except OSError:
            pass

    def __enter__(self):
        self.dll_dirs = []
        return self

    def __exit__(self, *exc_details):
        for d in self.dll_dirs:
            d.close()


def build_directory_manager():
    return DllDirectoryManager()
